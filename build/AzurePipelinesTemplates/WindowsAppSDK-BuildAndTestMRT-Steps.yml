parameters:
- name: "SignOutput"
  type: boolean
  default: False
- name: "IsOneBranch"
  type: boolean
  default: True
- name: "RunVSTests"
  type: boolean
  default: False
- name: "RunPrefast"
  type: boolean
  default: False

steps:
- template: WindowsAppSDK-SetupBuildEnvironment-Steps.yml
  parameters:
    IsOneBranch: ${{ parameters.IsOneBranch }}

- ${{ if parameters.RunPrefast }}:
  # PREFast scan is enabled in this pipeline run, so we pass PreFastSetup to BuildAll.ps1 to get it to do the commonn setup steps, but short of
  # building the target via MSBuild.exe
  - task: PowerShell@2
    name: PreFastSetup
    inputs:
      filePath: 'BuildAll.ps1'
      arguments: -Platform "$(buildPlatform)" -Configuration "$(buildConfiguration)" -AzureBuildStep "PreFastSetup"

  # The PREFast task below only supports the VSBuild/MSbuild task, _not_ a direct call to MSBuild.exe.
  - task: MSBuild@1
    displayName: 'build MrtCore with MSBuild'
    inputs:
      platform: '$(buildPlatform)'
      solution: '$(Build.SourcesDirectory)\dev\MRTCore\mrt\MrtCore.sln'
      configuration: '$(buildConfiguration)'
      msbuildArguments: '/restore /binaryLogger:$(Build.SourcesDirectory)\dev\MRTCore\mrt\mrtcore.$(buildPlatform).$(buildConfiguration).binlog'

  # ToDo: WindowsAppSDK-BinaryAnalysis-steps.yml below ultimately invokes SDLNativeRules@2, which is out of support.
  # So for the time being, we explicitly call SDLNativeRules@3, which is currently supported. Consider eliminating this
  # extra step when we run PREFast as part of WindowsAppSDK-BinaryAnalysis-steps.yml below.
  - task: SDLNativeRules@3
    displayName: 'Guardian: PreFast@3'
    env:
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    continueOnError: true
    inputs:
      userProvideBuildInfo: 'auto'
      toolVersion: Latest

- ${{ if not( parameters.RunPrefast ) }}:
  - task: PowerShell@2
    name: BuildBinaries
    inputs:
      filePath: 'BuildAll.ps1'
      arguments: -Platform "$(buildPlatform)" -Configuration "$(buildConfiguration)" -AzureBuildStep "BuildMRT"

# component detection must happen *within* the build task
- task: ms.vss-governance-buildtask.governance-build-task-component-detection.ComponentGovernanceComponentDetection@0

# TODO: Reenable Managed tests after https://microsoft.visualstudio.com/OS/_workitems/edit/44407037
- ${{ if parameters.RunVSTests }}:
  # This is required to fix VSTest failing with
  # ##[error]This operation requires installation of Visual Studio with the Universal Windows Platform development workload selected
  - task: PowerShell@2
    displayName: "Installing Microsoft.VisualStudio.Workload.Universal component"
    inputs:
      targetType: inline
      workingDirectory: $(Build.SourcesDirectory)
      script: |
        Measure-Command {Invoke-Expression "cd C:\'Program Files (x86)\Microsoft Visual Studio'\Installer\; .\vs_installer.exe modify --installPath 'C:\Program Files\Microsoft Visual Studio\2022\Enterprise' --add Microsoft.VisualStudio.Workload.Universal --downloadThenInstall --quiet | Out-Null"; Write-Host "Total time taken:"} | Select-Object Minutes, Seconds

  # Run the test locally on the Azure VM.
  # Note arm is currently not exercised.
  - task: VSTest@2
    displayName: 'test MRT: ManagedTests'
    condition: and(succeeded(), or(eq(variables['buildPlatform'], 'x86'), eq(variables['buildPlatform'], 'x64')))
    inputs:
      testSelector: 'testAssemblies'
      testAssemblyVer2: '**\MrtCoreManagedTest.build.appxrecipe'
      searchFolder: 'BuildOutput\$(buildConfiguration)\$(buildPlatform)\MrtCoreManagedTest'
      testRunTitle: 'test MRT: ManagedTests - $(buildPlatform)'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

  - task: VSTest@2
    displayName: 'test MRT: UnitTests'
    # These 3 MRT test suites were previously being run in Helix, but they are now being run via WindowsAppSDK-RunTestsInPipeline-Job.yml instead.
    # Resort to running these tests right here on the current job agent if and only if we've got here from ProjectReunion-CI.yml, because we won't
    # be running these tests via WindowsAppSDK-RunTestsInPipeline-Job.yml later in this specific flow. Otherwise, we can generally skip these tests.
    condition: and(and(succeeded(), or(eq(variables['buildPlatform'], 'x86'), eq(variables['buildPlatform'], 'x64'))), in(variables['Build.Reason'], 'IndividualCI', 'BatchCI'))
    inputs:
      testSelector: 'testAssemblies'
      testAssemblyVer2: '**\MrmUnitTest.dll'
      searchFolder: 'BuildOutput\$(buildConfiguration)\$(buildPlatform)\MrmUnitTest'
      testRunTitle: 'test MRT: UnitTests - $(buildPlatform)'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

  - task: VSTest@2
    displayName: 'test MRT: BaseUnitTests'
    condition: and(and(succeeded(), or(eq(variables['buildPlatform'], 'x86'), eq(variables['buildPlatform'], 'x64'))), in(variables['Build.Reason'], 'IndividualCI', 'BatchCI'))
    inputs:
      testSelector: 'testAssemblies'
      testAssemblyVer2: '**\MrmBaseUnitTests.dll'
      searchFolder: 'BuildOutput\$(buildConfiguration)\$(buildPlatform)\MrmBaseUnitTests'
      testRunTitle: 'test MRT: BaseUnitTests - $(buildPlatform)'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

  - task: VSTest@2
    displayName: 'test MRT: UnpackagedTests'
    condition: and(and(succeeded(), or(eq(variables['buildPlatform'], 'x86'), eq(variables['buildPlatform'], 'x64'))), in(variables['Build.Reason'], 'IndividualCI', 'BatchCI'))
    inputs:
      testSelector: 'testAssemblies'
      testAssemblyVer2: '**\MRTCoreUnpackagedTests.dll'
      searchFolder: 'BuildOutput\$(buildConfiguration)\$(buildPlatform)\MrtCoreUnpackagedTests'
      testRunTitle: 'test MRT: UnpackagedTests - $(buildPlatform)'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

- ${{ if eq(parameters.SignOutput, 'true') }}:
  - task: EsrpCodeSigning@2
    inputs:
      ConnectedServiceName: 'Project Reunion ESRP Code Signing Connection'
      FolderPath: '$(build.SourcesDirectory)\BuildOutput'
      Pattern: |
        **/*.winmd
        **/*.dll
        **/*.exe
      UseMinimatch: true
      signConfigType: 'inlineSignParams'
      inlineOperation: |
        [
          {
            "keyCode": "CP-230012",
            "operationSetCode": "SigntoolSign",
            "parameters": [
              {
                "parameterName": "OpusName",
                "parameterValue": "Microsoft"
              },
              {
                "parameterName": "OpusInfo",
                "parameterValue": "http://www.microsoft.com"
              },
              {
                "parameterName": "PageHash",
                "parameterValue": "/NPH"
              },
              {
                "parameterName": "FileDigest",
                "parameterValue": "/fd sha256"
              },
              {
                "parameterName": "TimeStamp",
                "parameterValue": "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
              }
            ],
            "toolName": "signtool.exe",
            "toolVersion": "6.2.9304.0"
          }
        ]
      SessionTimeout: '60'
      MaxConcurrency: '50'
      MaxRetryAttempts: '5'

- task: CopyFiles@2
  displayName: MoveToOutputDirectory
  inputs:
    SourceFolder: '$(build.SourcesDirectory)\BuildOutput'
    TargetFolder: '$(ob_outputDirectory)'

- ${{ if not( parameters.IsOneBranch ) }}:
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(ob_outputDirectory)'
      artifactName: '$(ob_artifactBaseName)'