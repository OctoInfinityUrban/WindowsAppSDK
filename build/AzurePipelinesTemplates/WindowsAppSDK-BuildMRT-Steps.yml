parameters:
- name: "SignOutput"
  type: boolean
  default: False
- name: "IsOneBranch"
  type: boolean
  default: True
- name: "RunPrefast"
  type: boolean
  default: False

steps:
- template: WindowsAppSDK-SetupBuildEnvironment-Steps.yml
  parameters:
    IsOneBranch: ${{ parameters.IsOneBranch }}

- ${{ if parameters.RunPrefast }}:
  # PREFast scan is enabled in this pipeline run, so we pass PreFastSetup to BuildAll.ps1 to get it to do the commonn setup steps, but short of
  # building the target via MSBuild.exe
  - task: PowerShell@2
    name: PreFastSetup
    inputs:
      filePath: 'BuildAll.ps1'
      arguments: -Platform "$(buildPlatform)" -Configuration "$(buildConfiguration)" -AzureBuildStep "PreFastSetup"

  # The PREFast task below only supports the VSBuild/MSbuild task, _not_ a direct call to MSBuild.exe.
  - task: MSBuild@1
    displayName: 'build MrtCore with MSBuild'
    inputs:
      platform: '$(buildPlatform)'
      solution: '$(Build.SourcesDirectory)\dev\MRTCore\mrt\MrtCore.sln'
      configuration: '$(buildConfiguration)'
      msbuildArguments: '/restore /binaryLogger:$(Build.SourcesDirectory)\dev\MRTCore\mrt\mrtcore.$(buildPlatform).$(buildConfiguration).binlog'

  # ToDo: WindowsAppSDK-BinaryAnalysis-steps.yml below ultimately invokes SDLNativeRules@2, which is out of support.
  # So for the time being, we explicitly call SDLNativeRules@3, which is currently supported. Consider eliminating this
  # extra step when we run PREFast as part of WindowsAppSDK-BinaryAnalysis-steps.yml below.
  - task: SDLNativeRules@3
<<<<<<< HEAD
    displayName: 'Guardian: PreFast@3'
=======
    displayName: Run PREfast SDL Native Rules
    condition: and(succeeded(), eq(variables['buildPlatform'], 'x64'), eq(variables['buildConfiguration'], 'Release'))
    inputs:
      setupCommandlines: '"C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsMSBuildCmd.bat"'
      msBuildArchitecture: amd64
      msBuildCommandline: 'msbuild.exe /nologo /nr:false /p:configuration=Release /p:platform=x64 $(Build.SourcesDirectory)\dev\MRTCore\mrt\MrtCore.sln'
      # Generally speaking, we leave it to the external repos to scan the bits in their packages.
      excludedPaths: |
        $(Build.SourcesDirectory)\packages
>>>>>>> 9ca4c669 (Update ESRPCodeSigningTask to Version 5; Use WindowsAppSDK-EsrpCodeSigning-Steps.yml From WindowsAppSDKConfig Repository (#4499))
    env:
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    continueOnError: true
    inputs:
      userProvideBuildInfo: 'auto'
      toolVersion: Latest

- ${{ if not( parameters.RunPrefast ) }}:
  - task: PowerShell@2
    name: BuildBinaries
    inputs:
      filePath: 'BuildAll.ps1'
      arguments: -Platform "$(buildPlatform)" -Configuration "$(buildConfiguration)" -AzureBuildStep "BuildMRT"

# component detection must happen *within* the build task
- task: ms.vss-governance-buildtask.governance-build-task-component-detection.ComponentGovernanceComponentDetection@0

- ${{ if eq(parameters.SignOutput, 'true') }}:
  - template: AzurePipelinesTemplates/WindowsAppSDK-EsrpCodeSigning-Steps.yml@WindowsAppSDKConfig
    parameters:
      FolderPath: '$(build.SourcesDirectory)\BuildOutput'
      UseMinimatch: true
      Pattern: |
        **/*.winmd
        **/*.dll
        **/*.exe
      KeyCode: 'CP-230012'
      displayName: 'Authenticode CodeSign Binaries'

- task: CopyFiles@2
  displayName: MoveToOutputDirectory
  inputs:
    SourceFolder: '$(build.SourcesDirectory)\BuildOutput'
    TargetFolder: '$(ob_outputDirectory)'

- ${{ if not( parameters.IsOneBranch ) }}:
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(ob_outputDirectory)'
      artifactName: '$(ob_artifactBaseName)'